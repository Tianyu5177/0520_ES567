<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>对象的深度克隆</title>
</head>
<body>
<!--
  1、数据类型：
    * 数据类型分为：
        -基本的数据类型(String, Number, boolean, Null, Undefined, Symbol)
            特点： 存储的是该对象的实际数据
        -对象数据类型
            特点： 存储的是该对象在栈中引用，真实的数据存放在堆内存里
      
  2、复制数据
    - 基本数据类型存放的就是实际的数据，可直接复制
      let number2 = 2;
      let number1 = number2;
    - 克隆数据：对象/数组
      1、区别： 浅拷贝/深度拷贝
         判断： 拷贝是否产生了新的数据还是拷贝的是数据的引用
         知识点：对象数据存放的是对象在栈内存的引用，直接复制的是对象的引用
         let obj = {username: 'kobe'}
         let obj1 = obj; // obj1 复制了obj在栈内存的引用
      2、常用的拷贝技术
        1). arr.concat(): 数组浅拷贝
        2). arr.slice(): 数组浅拷贝
        3). JSON.parse(JSON.stringify(arr/obj)): 数组或对象深拷贝, 但不能处理函数数据,函数会变成null
        4). 浅拷贝包含函数数据的对象/数组
        5). 深拷贝包含函数数据的对象/数组

      3、扩展：如何做到精准判断数据类型？
        用：Object.prototype.toString.call(xx)，可以获得类似 [object Type] 的字符串。
        且注意：这种方式判断NaN，返回的是[object Number]
        
        Object.prototype.toString.call(1) //[object Number]
        Object.prototype.toString.call('1') //[object String]
        Object.prototype.toString.call(undefined) //[object Undefined]
        Object.prototype.toString.call(true)// [object Boolean]
        Object.prototype.toString.call(console.log)//[object Function]
        Object.prototype.toString.call(Symbol())//[object Symbol]
        Object.prototype.toString.call(b) //报错
        Object.prototype.toString.call([]) //[object Array]
        Object.prototype.toString.call({}) //[object Object]
        Object.prototype.toString.call(NaN)//[object Number]-------注意这里

-->
<script type="text/javascript">
  
  let a = 1
  let b = a
  a = 5
  console.log(b)
  
  let obj = {
    name:'kobe',
    age:18
  }
  
  let obj2 = obj
  obj.name = 'wade'
  console.log(obj2)

//1.通过arr.concat(): 数组浅拷贝
let arr = [2,4,6,8,{name:'kobe'}]
let arr2 = []
arr2 = arr2.concat(arr)
arr[4].name = 'haha'
console.log(arr2);

//2.通过arr.slice(): 数组浅拷贝
let arr = [2,4,6,8,{name:'kobe'}]
let arr2 = []
arr2 = arr.slice(0)
arr[4].name = 'haha'
console.log(arr2);

//3.通过JSON.parse进行深度复制(缺陷：会把函数对象搞丢)
let arr1 = [2,4,6,8,{name:'kobe'},function demo(){console.log(1)}]
let arr2 = JSON.parse(JSON.stringify(arr1))
arr1[4].name = 'wade'
console.log(arr1);
console.log(arr2);

//手写一个深度复制
let obj = {name:'kobe',age:18}
console.log(obj.toString());

let arr = [2,4,6,8]
console.log(arr.toString());

let demo = Object.prototype.toString.call(arr)
console.log(demo);

console.log(Object.prototype.toString.call(1)); //[object Number]
console.log(Object.prototype.toString.call('1')); //[object String]
console.log(Object.prototype.toString.call(undefined)); //[object Undefined]
console.log(Object.prototype.toString.call(true));// [object Boolean]
console.log(Object.prototype.toString.call(console.log));//[object Function]
console.log(Object.prototype.toString.call(Symbol()));//[object Symbol]
console.log(Object.prototype.toString.call(null));//[object Null]
console.log(Object.prototype.toString.call([])); //[object Array]
console.log(Object.prototype.toString.call({})); //[object Object]
console.log(Object.prototype.toString.call(NaN));//[object Number]-------注意这里

//专门用于判断数据类型
function getType(target) {
  return Object.prototype.toString.call(target).slice(8,-1)
}
function deepClone(target) {
  let result = null
  if(getType(target) === 'Object'){
    result = {}
  }
  else if(getType(target) === 'Array'){
    result = []
  }
  else{
    return target
  }
  for (let key in target){
    let item = target[key]
    if(getType(item) === 'Object'||getType(item) === 'Array'){
      result[key] = deepClone(item)
    }else{
      result[key] = item
    }
  }
  return result
}

let obj = {
  name:'kobe',
  age:18,
  sex:{
    option1:'男',
    option2:'女',
    option3:'不男不女',
  },
  getInfo(){
    return this.name + this.age
  }
}

let obj2 = deepClone(obj)

obj.sex.option3 = '人妖'
obj.age = 19
console.log(obj)
console.log(obj2)
console.log(obj.getInfo())
console.log(obj2.getInfo())



</script>
</body>
</html>